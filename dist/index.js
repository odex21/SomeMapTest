import t,{Grid as e}from"pathfinding";class s{constructor({canvasWidth:t,canvasHeight:e,father:s,ctx:i}){this.perspective={PERSPECTIVE:.8*this.canvasWidth||1e3,PROJECTION_CENTER_X:this.canvasWidth/2||500,PROJECTION_CENTER_Y:this.canvasHeight/2||500},this.canvasWidth=t,this.canvasHeight=e,this.father=s,this.ctx=i,this.x=0,this.y=0,this.z=0,this.theta=0,this.phi=0,this.radius=10,this.globalRadius=this.canvasWidth/3,this.xProjected=0,this.yProjected=0,this.scaleProjected=0}project({x:t,y:e,z:s},{PERSPECTIVE:i,PROJECTION_CENTER_X:o,PROJECTION_CENTER_Y:h}){const r=i/(i+e);return{size:r,x:t*r+o,y:s*r+h}}update(){this.father&&this.father.draw(!0)}}const i=(t,e,s,i=!0)=>{let o,h=Object.assign({},t);const r=Object.fromEntries(Object.keys(s).map(e=>{const i=s[e]-t[e];return[e,{v:Math.abs(i),face:i>0}]}));return new Promise((a,n)=>{const c=n=>{o||(o=n);const l=n-o+0;Object.entries(r).forEach(([s,{v:i,face:o}])=>{t[s]=o?h[s]+i*l/e:h[s]-i*l/e}),l<e?requestAnimationFrame(c):i?(h=Object.assign({},t),o=n,Object.keys(r).forEach(t=>r[t].face=!r[t].face),requestAnimationFrame(c)):(console.log("sfsd",h,s),a())};requestAnimationFrame(c)})},o=(t,e)=>{Object.keys(t).forEach(s=>{void 0!==t[s]&&(e[s]="object"==typeof t[s]?Object.assign(e[s]||{},t[s]):t[s])})},h=t=>(e,s)=>{e.backUpAttr.state.changed?e.restore():(o({faceColor:e.faceColor},e.backUpAttr.attr),o({changed:!0},e.backUpAttr.state),e.faceColor[1]=t||((t,e)=>t.map(t=>((t,e)=>"number"==typeof t?t*e:+t.slice(0,-1)*e+t.slice(-1))(t,e)))(e.faceColor[1],1.5)),e.update()},r=t=>new Promise((e,s)=>{setTimeout(()=>e(),t)}),a=(t,e,s,i,o)=>({x:h,y:r})=>({x:(h-t/2+i)*s,y:(r-e/2+o)*s}),n=(t,{vector:e,colors:s})=>{const{p1:i,p2:o}=e,h=t.createLinearGradient(i.x,i.y,o.x,o.y);return s.forEach(({color:t,p:e})=>{h.addColorStop(e,t)}),h};class c{constructor(t=1,e=(()=>{}),s=[]){return this.concurrency=t,this.running=0,this.queue=s,this.finalTask=e,this}pushTask(t){this.queue.push(t),this.next()}clear(){this.queue=[]}next(){for(;this.running<this.concurrency&&this.queue.length;){this.queue.shift()().then(()=>{this.running--,this.next()}),this.running++}0===this.running&&0===this.queue.length&&this.finalTask()}}const l=(t,e)=>{const s=[];let i,o=[],h=[];return t.forEach(t=>{const{x:r,y:a}=t.pos;void 0===i&&(i=a),a!==i&&(i=a,s.push(...o.reverse(),...h),o=[],h=[]),r<e/2?h.push(t):o.push(t)}),s.push(...h,...o.reverse()),s},d=t=>new Promise(e=>{const s=new Image;s.src=t,s.onload=()=>e(s)});var p,u;!function(t){t[t.red=0]="red",t[t.green=1]="green",t[t.blue=2]="blue",t[t.alpha=3]="alpha"}(p||(p={})),function(t){t[t.hue=0]="hue",t[t.saturation=1]="saturation",t[t.lightness=2]="lightness",t[t.alpha=3]="alpha"}(u||(u={}));const f=t=>"string"==typeof t,g=t=>"string"==typeof t?t:((t,e)=>`${t}(${e.join(",")})`)((t=>f(t[1])&&f(t[2])?t[3]?"hsla":"hsl":t[3]?"rgba":"rgb")(t),t),m=(t,e)=>void 0!==t?t:(Math.random()-.5)*e,y=[[0,1],[1,3],[3,2],[2,0],[2,6],[3,7],[0,4],[1,5],[6,7],[6,4],[7,5],[4,5]],x=[[0,1,3,2],[0,1,5,4],[3,2,6,7],[4,5,7,6],[0,2,6,4],[1,3,7,5]],v=[[-1,-1,-1],[1,-1,-1],[-1,1,-1],[1,1,-1],[-1,-1,1],[1,-1,1],[-1,1,1],[1,1,1]];class w extends s{constructor(t){super(t),this.faces=[],this.faceColor={0:[48,48,48,.75],1:[200,32,32,.9],2:[41,41,41,.9]},this.todo={},this.strokeStyle="rgba(64, 170, 191, 0.5)",this.backUpAttr={attr:{},state:{}},this.text="";const{cubeLength:e,cubeWidth:s,cubeHeight:i,canvasWidth:o,canvasHeight:r,x:a,y:n,z:c,radius:l,theta:d,faceColor:p,pos:u}=t;this.radius=l||Math.floor(12*Math.random()+10),this.pos=u,this.width=s||this.radius,this.height=i||l||10,this.length=e||this.radius,t.text&&(this.text=t.text),this.x=m(a,o),this.y=m(n,r),this.z=m(c,r),p&&(this.faceColor[1]=p),this.theta=d||0,this.ctx.lineJoin="round",this.ctx.lineWidth=2,this.on("click",h())}restore(){o({...this.backUpAttr.attr},this),o({changed:!1},this.backUpAttr.state)}set(t){o(t,this)}pointInPath(t){const e=this.faces.some(e=>this.ctx.isPointInPath(e,t.x,t.y));return!!e&&(this.todo[t.type]&&this.todo[t.type].forEach(t=>t.call(this,this,this.father)),e)}on(t,e){this.todo[t]||(this.todo[t]=[]),this.todo[t].push(e)}animate(t){i(this,1e4,t)}viToXy([t,e,s]){const i={x:this.x+this.width*t,z:this.z+this.length*s,y:this.y+this.height*e};return this.project((({x:t,y:e,z:s})=>({x:t,y:e*Math.cos(this.theta)+s*Math.sin(this.theta),z:e*Math.sin(this.theta)+s*Math.cos(this.theta)}))(i),this.perspective)}drawFace(t=1){const e=new Path2D,s=this.ctx;x[t].forEach((t,s)=>{const{x:i,y:o}=this.viToXy(v[t]);0===s?e.moveTo(i,o):e.lineTo(i,o)}),e.closePath();const i=this.faceColor[t]||this.faceColor[0];if(s.fillStyle=g(i),s.fill(e),1===t){let t=0===this.pos.x?this.pos.y:0===this.pos.y?this.pos.x:this.text;const{x:e,y:i}=this.viToXy(this.text.length>3?[1,-1,-.2]:[.5,0,-.1]);s.font=`${this.text.length>2?this.radius/2.3:this.radius/1.2}px sans-serif`,s.fillStyle="rgba(255, 255, 255, 0.7)",s.textAlign="right",s.fillText(t+" ",e,i)}s.restore(),0!==t&&1!==t||(this.faces[t]=e)}draw(){const t=this.ctx;this.z<-this.perspective.PERSPECTIVE+this.radius||(t.save(),this.ctx.lineWidth=1,t.strokeStyle=this.strokeStyle,y.forEach((e,s)=>{if(2===s||8===s)return;const i=this.viToXy(v[e[0]]),o=this.viToXy(v[e[1]]);t.beginPath(),t.moveTo(i.x,i.y),t.lineTo(o.x,o.y),this.ctx.strokeStyle=this.strokeStyle,t.stroke()}),t.restore(),this.drawFace(0),this.drawFace(1))}}const b={tile_bigforce:{name:"特种战术点",description:"置于其中的我方单位在推动或拉动敌方单位时力度增大",color:[342,"98%","67%",1]},tile_def:{name:"防御符文",description:"置于其中的干员获得额外的防御力",color:[342,"98%","67%",1]},tile_defup:{name:"防御符文",description:"置于其中的干员获得额外的防御力",color:[342,"98%","67%",1]},tile_fence:{name:"围栏",description:"可放置近战单位，不可以通行",color:[342,"98%","67%",1]},tile_healing:{name:"医疗符文",description:"置于其中的干员会持续恢复生命",color:[342,"98%","67%",1]},tile_rcm_crate:{name:"推荐障碍放置点",description:"PRTS推荐的障碍物放置点",color:[342,"98%","67%",1]},tile_rcm_operator:{name:"推荐干员放置点",description:"PRTS推荐的战术放置点",color:[342,"98%","67%",1]},tile_shallowwater:{name:"浅水区",description:"代表岸边的水地形",color:[342,"98%","67%",1]},tile_corrosion:{name:"腐蚀地面",description:"置于其中的干员防御力减半",color:[179,"18%","42%",1]},tile_deepwater:{name:"深水区",description:"代表离岸较远的水地形",color:[224,"100%","25%",.7]},tile_end:{name:"保护目标",description:"蓝色目标点，敌方进入后会减少此目标点的耐久",color:[189,"96%","37%"]},tile_floor:{name:"不可放置位",description:"不可放置单位，可以通行",color:[38,"92%","90%",1]},tile_flystart:{name:"空袭侵入点",description:"敌方飞行单位会从此处进入战场",color:[0,"95%","61%"]},tile_forbidden:{name:"禁入区",description:"不可放置单位，不可通行",color:[230,230,230,.3]},tile_gazebo:{name:"防空符文",description:"置于其中的干员攻击速度略微下降，但在攻击空中单位时攻击力大幅度提升",color:[48,"83%","57%",1]},tile_grass:{name:"草丛",description:"置于其中的干员不会成为敌军远程攻击的目标",color:[31,244,81]},tile_hole:{name:"地穴",description:"危险的凹陷地形或地面破洞，经过的敌人会摔落至底部直接死亡",color:[219,"57%","14%",1]},tile_infection:{name:"活性源石",description:"部署的友军和经过的敌军获得攻击力和攻击速度提升的效果，但会持续失去生命",color:[235,123,21]},tile_road:{name:"平地",description:"可以放置近战单位，可以通行",color:[240,240,240]},tile_start:{name:"侵入点",description:"敌方会从此进入战场",color:[255,61,61]},tile_telin:{name:"通道入口",description:"敌方会从此进入通道，从通道出口出现",color:[244,152,0]},tile_telout:{name:"通道出口",description:"进入通道的敌方单位会从此处再度出现",color:[244,152,0]},tile_volcano:{name:"热泵通道",description:"每隔一段时间便会喷出高温气体，对其上的任何单位造成无视防御和法抗的伤害",color:[25,"100%","49%",.9]},tile_volspread:{name:"岩浆喷射处",description:"每隔一段时间会喷出岩浆，对周围8格内的我方单位造成大量伤害且可以融化障碍物",color:[0,"100%","24%"]},tile_wall:{name:"高台",description:"可以放置远程单位，不可通行",color:[125,253,244,.9]},tile_defbreak:{name:"腐蚀地面",description:"置于其中的干员防御力减半",color:[179,"18%","42%",1]}};class E extends s{constructor(t){super(t),this.absPath=[],this.strokeStyle="rgba(0, 0, 0, 0)",this.i=0,this.points=t.points,this.x=0,this.y=t.y||20,this.z=0,this.width=t.width||5}set(t){o(t,this)}init(){this.absPath=this.points.map(t=>this.viToXy(t));const t=new Path2D;this.absPath.forEach(({x:e,y:s},i)=>{0===i?t.moveTo(e,s):t.lineTo(e,s)}),this.path=t}draw(){this.ctx.save(),this.ctx.lineWidth=this.width,this.init(),this.ctx.lineDashOffset=-this.i++,this.i>100*this.radius&&(this.i=0),this.ctx.setLineDash([3.5*this.radius*2,2*this.radius*2]),this.ctx.strokeStyle=this.strokeStyle,this.ctx.stroke(this.path),this.ctx.restore()}viToXy({x:t,y:e}){const s=this.y;return this.project((({x:t,y:e,z:s})=>({x:t,z:e*Math.cos(this.theta)+s*Math.sin(this.theta),y:e*Math.sin(this.theta)+s*Math.cos(this.theta)}))({x:t,z:s,y:e}),this.perspective)}}class P extends E{constructor(t){super(t),this._gradientColors=[{color:"rgba(0, 0, 0, 0)",p:0},{color:"rgba(0, 0, 0, 0)",p:1}],this.run=!0,this.gradientColors=t.gradientColors||this._gradientColors,this.time=t.time||2e3,this.color=t.color||360*Math.random()}update(){this.father.update()}animate(t,e){const s=t|this.time,i=e|this.color;return new Promise((t,e)=>{let o;const h=e=>{o||(o=e);const r=e-o+0;if(!this.run)return void t(r);let a=0,n=Math.min(r/s,1);n>.618&&(a=1-(1-n)/.382),n=Math.min(n/.7,1);const c=[{p:0,color:`hsla(${i}, 100%, 50%, 0.1)`},{p:a,color:`hsla(${i}, 100%, 50%, 0.7)`},{p:n,color:`hsla(${i}, 100%, 35%, 1)`},{p:Math.min(n+.02,1),color:`hsla(${i}, 100%, 50%, 0)`}];this.gradientColors=c,this.update(),r<s?requestAnimationFrame(h):t()};requestAnimationFrame(h)})}set strokeStyle(t){}get strokeStyle(){const t=this.absPath;return 0===t.length?"？？？？？？？":n(this.ctx,{vector:{p1:t[0],p2:t[this.points.length-1]},colors:this.gradientColors})}set gradientColors(t){if(!t)throw Error("fuck you");this._gradientColors=t}get gradientColors(){return this._gradientColors}}class T extends w{constructor(t){super(t),this.tileInfo=t.tileInfo}}const k=(t,e,s)=>(t[e]=s(t[e]),t),C=t=>e=>t?{col:e.col+t.x,row:e.row+t.y}:e,_=(t,e)=>t.col===e.col&&t.row===e.row,R=(t,e)=>t>e?[e,t]:[t,e],M=Math.abs;let O;const z=(e,s,i,o,h)=>{if(!h)throw Error("No grid !");const[r,a]=R(e,i),[n,c]=R(s,o),l=a-r,d=c-n,p=e===r?0:l,u=s===n?0:d,f=i===r?0:l,g=o===n?0:d,m=h.nodes.filter((t,e)=>e<=c&&e>=n).map(t=>t.filter((t,e)=>e<=a&&e>=r).map(t=>t.walkable?0:1));try{m[g][f]=0}catch(t){console.error(g,f,m)}const y=m.flat().filter(t=>1===t).length;if(y){const[h,a]=R(M(e-i),M(s-o));if(1===h&&a>2&&1===y)return[i,o];const c=t.Util.compressPath(O.findPath(p,u,f,g,new t.Grid(m)));return 0===c.length?[-1,-1]:[r+c[1][0],n+c[1][1]]}return[i,o]},S=t=>({x:t.col,y:t.row}),I=(e,s)=>{const{height:i}=s.data,{startPosition:o,endPosition:h,checkpoints:r}=e;O=new t.AStarFinder({diagonalMovement:4,weight:Math.min(M(o.col-h.col),M(o.row-h.row)),heuristic:t.Heuristic.octile});const a=s.grid,n=r.filter(t=>t.type<4||6===t.type),c=n.map(t=>({...t.position,type:t.type,reachOffset:t.reachOffset})),l=c.some(t=>6===t.type);c.push(h);const d=1===e.motionMode,p=d?new t.Grid(a.width,a.height):a.clone();p.setWalkableAt(h.col,h.row,!0);let u=o;return c.reduce((s,i,o,h)=>{let{col:r,row:a}=u,c=h[o],{col:f,row:g,reachOffset:m}=c;if(6===c.type)return u=i,s;if(0===f&&0===g){const t=n[o].time?n[o].time:0;return s.push({stop:{pos:S(h[o-1]||u),time:t}}),s}let y=[u];d&&y.push(c);const x=e.allowDiagonalMove;if(!d&&!l&&x){let[e,s]=[r,a],i=[],o=M(f-r),h=M(g-a);for(;o+h>1;){if([e,s]=z(e,s,f,g,p),e>-1&&s>-1)y.push({col:e,row:s});else{if(i=(e=>{if(e.length>1)return e.slice(1);{const e=t.Util.compressPath(O.findPath(r,a,f,g,p));if(e.length<1)throw Error("can not find a way to the point");return e.slice(1)}})(i),[e,s]=i.shift(),y.length>1)for(;_({col:e,row:s},y[y.length-2]);)console.log("应该没这样的了吧"),[e,s]=i.shift();y.push({col:e,row:s})}o=M(f-e),h=M(g-s)}}_(c,y[y.length-1])||y.push(c),y=k(y,0,C(u.reachOffset)),y=k(y,y.length-1,C(m)),u=i;let v=y.shift();return y.reduce((t,e)=>{const{col:s,row:i}=v,o=Math.sqrt((s-e.col)**2+(i-e.row)**2);return t.push({points:[S(v),S(e)],time:200*o||10}),v=e,t},s)},[])};class H extends w{constructor(t){super(t),this.time=t.time,this.faceColor[0]=[41,230,41,.1]}drawFace(t=1){const e=new Path2D,s=this.ctx;x[t].forEach((t,s)=>{const{x:i,y:o}=this.viToXy(v[t]);0===s?e.moveTo(i,o):e.lineTo(i,o)}),e.closePath();const i=this.faceColor[t]||this.faceColor[0];if(s.fillStyle=g(i),s.fill(e),1===t){const{x:t,y:e}=this.viToXy(this.time>99?[0,0,-.2]:[.1,0,-.2]);0===this.pos.x?this.pos.y:0===this.pos.y?this.pos.x:this.text;s.font=`${this.radius/1.2}px sans-serif`,s.fillStyle="white",s.textAlign="center",s.fillText(this.time+"s ",t,e)}s.restore(),0!==t&&1!==t||(this.faces[t]=e)}animate(){return Promise.resolve()}}const W=t=>e=>{const s={x:e.layerX*t.scale,y:e.layerY*t.scale,type:e.type};for(let e=t.dots.length-1;e>-1;e--){if(t.dots[e].pointInPath(s))break}};export default class{constructor(t,e=-75/360*Math.PI,s,i,o){this.dots=[],this.i=0,this.theta=0,this.data={width:8,height:4},this.drawing=!1,this.routes=new Map,this.looping=!0,this.scale=2,this.defaultHandler=W(this),this.config(t,s,e),this.init(i,o),this.loop()}loop(){requestAnimationFrame(()=>{this.draw(!1).then(()=>this.looping&&this.loop())})}config(t,e,s){this.canvas=t;let{width:i,height:o}=this.canvas.getBoundingClientRect();i>1e3&&(this.scale=1.5),i*=this.scale,o*=this.scale,this.canvas.width=i,this.canvas.height=o,this.context=this.canvas.getContext("2d"),this.canvasWidth=i,this.canvasHeight=o,this.baseOpt={ctx:this.context,father:this,canvasWidth:i,canvasHeight:o},this.baseFloor=new w({...this.baseOpt,x:0,z:0,y:2,cubeHeight:2,faceColor:"#414141",cubeLength:o/2,cubeWidth:i/2,pos:{x:0,y:0}});const h={perspective:{PERSPECTIVE:e,PROJECTION_CENTER_X:i/2,PROJECTION_CENTER_Y:o/2},theta:s};this.setPerspective(h)}init(t,s){var i;this.r=Math.min(this.canvas.width/t.width,this.canvas.height/t.height),this.xz=a(t.width,t.height,this.r,.5,.5),this.RawRoutes=s,this.dots=[],this.routes=new Map;const o=this.r,{width:h,height:r}=t,{width:n,height:c}=this.canvas,d=.1*o,p=.3*o,u=[];for(let e=r-1;e>-1;e--){const s=[],r=[],a=[];for(let l=h-1;l>-1;l--){const{x:u,y:f}=this.xz({x:l,y:e}),g={x:u,z:f,canvasWidth:n,canvasHeight:c,radius:o/2,pos:{x:l,y:e},ctx:this.context,father:this},m=t.tiles[e*h+l],{tileKey:y,passableMask:x}=m,v=/end|hole/.test(y)||3!==x?1:0;a.push(v);let w=m.extra||b[m.tileKey];w||(console.error("can not find data"),console.log(m.tileKey),w={color:"black"}),m.blackboard&&(w.blackboard=m.blackboard);const E=(m.heightType?p+d:d)/2,P=null===(i=m.extra)||void 0===i?void 0:i.name,k=new T({...g,cubeHeight:E,y:(m.heightType,-E),faceColor:w.color,tileInfo:w,text:P});m.heightType?s.push(k):r.push(k),m.events&&Object.entries(m.events).forEach(([t,e])=>{e.forEach(e=>{k.on(t,e)})})}u.push(a.reverse()),this.dots.push(...l(r,h),...l(s,h))}this.grid=new e(u.reverse());const{perspective:f,theta:g}=this;f&&g&&this.setPerspective({perspective:f,theta:g}),this.canvas.removeEventListener("click",this.defaultHandler),this.canvas.addEventListener("click",this.defaultHandler)}deleteRoute(t){this.routes.delete(t),0===this.routes.size&&(this.looping=!1)}deleteAll(){this.routes.clear()}async loopRoutes(t=0,e=this.RawRoutes.length){this.RawRoutes.slice(t,e).map((t,e)=>{t&&this.initRoute(t,e)})}loopRoute(t,e){if(this.routes.has(t))this.routes.delete(t);else{const s=this.RawRoutes[t];s&&(this.looping=!0,this.loop(),this.initRoute(s,t,e))}}initRoute(t,e,s=Math.floor(360*Math.random())){const{canvasHeight:i,canvasWidth:h}=this,r=I(t,this).map(({points:e,time:r,stop:a})=>{const n=1===t.motionMode;if(e)return this.initPath(e,r,s,n);if(a){const{x:t,y:e}=this.xz(a.pos),r=new H({x:t,z:e,y:n?-this.r/1.2:-this.r/4,cubeHeight:.05*this.r/2,canvasWidth:h,canvasHeight:i,radius:this.r/2,pos:{x:t,y:e},ctx:this.context,father:this,time:a.time,faceColor:[s,"100%","50%",.7]});return o({perspective:this.perspective,theta:this.theta},r),r}return{animate:()=>Promise.resolve(),draw:()=>{},set:()=>{}}});this.routes.set(e,r);(()=>{const t=r.map(t=>t.animate.bind(t));new c(1,()=>{console.log("next")},t).next()})()}initPath(t,e=2e3,s,i=!1){const h=t.map(t=>this.xz(t)),r=new P({...this.baseOpt,width:this.r/10,y:i?-this.r:-this.r/3,r:this.r,points:h,time:e,color:s});return o({perspective:this.perspective,theta:this.theta},r),r}setPerspective(t){o(t,this),this.dots.forEach(e=>e.set(t)),this.routes.forEach(e=>e.forEach(e=>e.set(t))),this.baseFloor.set(t),this.draw(!0)}update(){}async draw(t){this.drawing&&(this.drawing=!1,await r(100)),this.drawing=!0,this.context.clearRect(0,0,this.canvasWidth,this.canvasHeight);const e=new c(1,()=>this.drawing=!1);t?(e.pushTask(()=>(this.baseFloor.draw(),Promise.resolve())),this.dots.forEach(t=>{e.pushTask(async()=>{this.drawing||e.clear(),t.draw()})})):this.background&&this.context.drawImage(this.background,0,0),this.routes.forEach(t=>{e.pushTask(async()=>{this.drawing||e.clear(),t.forEach(t=>t.draw())})}),t&&e.pushTask(async()=>{const t=this.canvas.toDataURL();this.background=await d(t)})}}
